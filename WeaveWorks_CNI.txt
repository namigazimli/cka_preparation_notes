The WeaveWorks is weave CNI plugin. The networking solution we set up manually had a routing table which mapped what networks are on what hosts. When a packet is sent from one Pod to the other, it goes out to the network, to the router and finds its way to the node that hosts that Pod. Now that works for a small environment and in a simple network. But in larger environments with 100s of nodes in a cluster and 100s of Pods on each node, this is not practical. The routing table may not support so many entries and that is where you need to get creative and look for other solutions. Think of the Kubernetes cluster as our company and the nodes as different office sites. With each site, we have different departments and within each department we have different offices. Someone in office-1 wants to send a packet to office-3 and hands it over to the office boy. All he knows is it needs to go to office-3 and he doesn't care who or how it is transported. The office boy takes the package, gets in his car, looks up address of the target office in GPS, uses directions on the street and finds his way to the destination site. Delivers the package to Payroll department who in turn forwards the package to office-3. This works fine for now. 

That's where we decide to outsource all mailing and shipping activities to a company who does it best. Once the shipping company is engaged, the first thing that they do is place their agents in each of our company's sites. These agents are responsible for managing all shipping activities between sites. They also keep talking to each other and are well connected. So they all know about each other's sites. So, when a package is sent from office-10 to office-3, the shipping agent in that site intercepts the package, and looks at the target office name. He knows exactly in which site and department that office is in through his little internal network with his peers on the other sites. He then places this package into his own new package with the destination address said to the target site's location and then sends the package through. Once the package arrives at the destination it is again intercepted by the agent on that site. He opens the packat retrieves the original packet and delivers it to the right department. 

Back to our world, when the weave CNI plugin is deployed on a cluster, it deploys an agent or service on each node. They communicate with each other to exchange information regarding the nodes and networks and Pods within them. Each agent or peer stores a topology of the entire setup. That way they know the Pods and their IPs on the other nodes. Weave creates its own bridge on the nodes and names it "weave". Then assigns IP address to each network. Remember that a single Pod may be attached to multiple bridge networks. Weave makes sure that Pods get the correct route configured to reach the agent. And the agent then takes care of other Pods. When a packet is sent from one Pod to another on another node, weave intercepts the packet and identifies that it's on a separate network. It then encapsulates this packet into a new one with new source and destination and sends it across the network. Once on other side, the other weave agent retrieves the packet, decapsulates and routes the packet to the right Pod. So how do we deploy weave on a Kubernetes cluster? Weave and weave peers can be deployed as services or daemons on each node in the cluster manually or if Kubernetes is setup already then an easier way to do that is to deploy it as Pods in the cluster. Once the base Kubernetes system is ready with nodes and networking configured correctly between the nodes and the basic control plane components are deployed, weave can be deployed in the cluster with a single "kubectl apply" command. This deploys all the necessary components required for weave in the cluster. 

--> kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"


